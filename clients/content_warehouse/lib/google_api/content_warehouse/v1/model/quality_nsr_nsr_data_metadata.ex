# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This file is auto generated by the elixir code generator program.
# Do not edit this file manually.

defmodule GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrDataMetadata do
  @moduledoc """
  Contains meta information about this data. This field is only available in docjoins (and potentially MDU shards), it is not populated offline. NOTE: This is a new field (Nov 2022) and we do not want clients to depend on this; please contact qscore-team@ if you want to use this information.

  ## Attributes

  *   `encodedLookupInformation` (*type:* `String.t`, *default:* `nil`) - Encoded lookup information. The fields set above are expensive to store. Storing them in docjoins is fine, but we cannot store them in MDU shards. In order for the MDU shards to display field provenance information, we store them as a bitfield. For details about the encoding and decoding scheme, see quality_nsr::util::EncodeMetadataLookupInformation. We expect this to occupy 8 bytes as long as there are less than 64 fields in NsrData proto, 12 bytes between 64 and 92 fields, etc.
  *   `goldmineLookupKeyPerField` (*type:* `map()`, *default:* `nil`) - Same as raffia_lookup_key_per_field. Note that the goldmine_lookups have priority; if a field appears in both goldmine and raffia entries, it means it was taken from goldmine. If it's missing here but present in raffia_lookup_key_per_field, it was taken from raffia.
  *   `goldmineLookupKeys` (*type:* `list(String.t)`, *default:* `nil`) - The lookup keys attempted by goldmine. Note that goldmine only runs for urls which can be chunked differently than raffia; in those cases, goldmine related fields are empty.
  *   `lastTimeProcessedGoldmineInSeconds` (*type:* `String.t`, *default:* `nil`) - 
  *   `lastTimeProcessedMduInSeconds` (*type:* `String.t`, *default:* `nil`) - This field is populated only during MDU population, so it's *not* present in docjoins, but it's present in production so that it can be displayed.
  *   `lastTimeProcessedRaffiaInSeconds` (*type:* `String.t`, *default:* `nil`) - Records the last time each system has processed the proto. These are recorded as seconds from the unix epoch. Ideally these fields would be google.protobuf.Timestamp, but the scoring bundle (which depends on this proto) does not understand proto3 syntax. See cl/500942047 for details.
  *   `nsrChunksWithSourceInfo` (*type:* `GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrChunksWithSourceInfo.t`, *default:* `nil`) - Stores the NSRChunks (computed by goldmine) which were used to populate the data.
  *   `raffiaLookupKey` (*type:* `String.t`, *default:* `nil`) - 
  *   `raffiaLookupKeyPerField` (*type:* `map()`, *default:* `nil`) - Returns the raffia lookup key per each field in the NsrData proto (with exclusion of the Metadata sub-message (i.e. this)). It contains information like 3 : 1, meaning that the field inside NsrData with id '3' (in this case 'host') has been taken by raffia from the raffia lookup key at index 1.
  *   `raffiaLookupKeys` (*type:* `list(String.t)`, *default:* `nil`) - This is an internal field set by Raffia, to indicate which lookup keys have been attempted to populate the NsrData for this document. This will allow us to determine which key has been used to populate each field in the proto. The keys are ordered by lookup priority; raffia will give priority to earlier keys, and only take fields from later keys if they are missing.
  *   `raffiaSignalMergerUrl` (*type:* `String.t`, *default:* `nil`) - The url used by NsrSignalMerger (http://google3/indexing/signals/signal-merger.h;l=1801;rcl=509297232) to select which NsrData value to keep. The SignalMerger merges all the NsrData coming from the dup url cluster, and select the NsrData value to return by choosing a single url in the cluster (see NsrSignalMerger class for details). NOTE: This field is populated only when there *is* a cluster. If there is no cluster, this is empty and the key used is the canonical (and only) url.
  """

  use GoogleApi.Gax.ModelBase

  @type t :: %__MODULE__{
          :encodedLookupInformation => String.t() | nil,
          :goldmineLookupKeyPerField => map() | nil,
          :goldmineLookupKeys => list(String.t()) | nil,
          :lastTimeProcessedGoldmineInSeconds => String.t() | nil,
          :lastTimeProcessedMduInSeconds => String.t() | nil,
          :lastTimeProcessedRaffiaInSeconds => String.t() | nil,
          :nsrChunksWithSourceInfo =>
            GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrChunksWithSourceInfo.t() | nil,
          :raffiaLookupKey => String.t() | nil,
          :raffiaLookupKeyPerField => map() | nil,
          :raffiaLookupKeys => list(String.t()) | nil,
          :raffiaSignalMergerUrl => String.t() | nil
        }

  field(:encodedLookupInformation)
  field(:goldmineLookupKeyPerField, type: :map)
  field(:goldmineLookupKeys, type: :list)
  field(:lastTimeProcessedGoldmineInSeconds)
  field(:lastTimeProcessedMduInSeconds)
  field(:lastTimeProcessedRaffiaInSeconds)

  field(:nsrChunksWithSourceInfo,
    as: GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrChunksWithSourceInfo
  )

  field(:raffiaLookupKey)
  field(:raffiaLookupKeyPerField, type: :map)
  field(:raffiaLookupKeys, type: :list)
  field(:raffiaSignalMergerUrl)
end

defimpl Poison.Decoder, for: GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrDataMetadata do
  def decode(value, options) do
    GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrDataMetadata.decode(value, options)
  end
end

defimpl Poison.Encoder, for: GoogleApi.ContentWarehouse.V1.Model.QualityNsrNsrDataMetadata do
  def encode(value, options) do
    GoogleApi.Gax.ModelBase.encode(value, options)
  end
end
