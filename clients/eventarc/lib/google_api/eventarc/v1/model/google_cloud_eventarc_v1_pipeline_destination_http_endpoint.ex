# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This file is auto generated by the elixir code generator program.
# Do not edit this file manually.

defmodule GoogleApi.Eventarc.V1.Model.GoogleCloudEventarcV1PipelineDestinationHttpEndpoint do
  @moduledoc """
  Represents a HTTP endpoint destination.

  ## Attributes

  *   `messageBindingTemplate` (*type:* `String.t`, *default:* `nil`) - Optional. The CEL expression used to construct a new HTTP request to be sent to the final destination. The result of the CEL expression must be a map of key/value pairs such that: - If a map named `headers` exists on the result of the expression, then its key/value pairs are directly mapped to the HTTP request headers. The headers values are constructed from the corresponding value type’s canonical representation. If the `headers` field doesn’t exist then the resulting HTTP request will be without headers. - If a field named `body` exists on the result of the expression then its value is directly mapped to the body of the request. If the value of the `body` field is of type bytes or string then it is used for the HTTP request body as-is, with no conversion. If the body field is of any other type then it is converted to a JSON string. If the body field doesn’t exist then the resulting HTTP request will be without a body. - Any other fields in the resulting expression will be ignored. The CEL expression may access the incoming CloudEvent message in its definition, as follows: - The `data` field of the incoming CloudEvent message can be accessed using the `message.data` value. - Each attribute of the incoming CloudEvent message can be accessed using the `message.` value, where is replaced with the name of the attribute. Headers added to the request by previous filters in the chain can be accessed in the CEL expression using the `headers` variable. The `headers` variable defines a map of key/value pairs corresponding to the HTTP headers added by previous mediation steps and not the headers present on the original incoming request. For example, the following CEL expression can be used to construct a Headers-only HTTP request by adding an additional header to the headers added by previous mediations in the Pipeline: ``` {"headers": headers.merge({"new-header-key": "new-header-value"})} ``` Additionally, the following CEL extension functions are provided for use in this CEL expression: - toBase64Url: map.toBase64Url() -> string - Converts a CelValue to a base64url encoded string - toJsonString: map.toJsonString() -> string - Converts a CelValue to a JSON string - merge: map1.merge(map2) -> map3 - Merges the passed CEL map with the existing CEL map the function is applied to. - If the same key exists in both maps, if the key's value is type map both maps are merged else the value from the passed map is used. - toMap: list(map).toMap() -> map - Converts a CEL list of CEL maps to a single CEL map - toDestinationPayloadFormat(): message.data.toDestinationPayloadFormat() -> string or bytes - Converts the message data to the destination payload format specified in Pipeline.Destination.output_payload_format - This function is meant to be applied to the message.data field. - If the destination payload format is not set, the function will return the message data unchanged. - toCloudEventJsonWithPayloadFormat: message.toCloudEventJsonWithPayloadFormat() -> map - Converts a message to the corresponding structure of JSON format for CloudEvents - This function applies toDestinationPayloadFormat() to the message data. It also sets the corresponding datacontenttype of the CloudEvent, as indicated by Pipeline.Destination.output_payload_format. If no output_payload_format is set it will use the existing datacontenttype on the CloudEvent if present, else leave datacontenttype absent. - This function expects that the content of the message will adhere to the standard CloudEvent format. If it doesn’t then this function will fail. - The result is a CEL map that corresponds to the JSON representation of the CloudEvent. To convert that data to a JSON string it can be chained with the toJsonString function. If a binding is not specified here, by default the message is treated as a CloudEvent and is mapped to the HTTP request according to the CloudEvent HTTP Protocol Binding Binary Content Mode. The Pipeline converts the data field of the message to the format provided in Pipeline.Destination.output_payload_format and maps it to the body field of the result. It also sets the corresponding Content-Type header to the output_payload_format type. If the Pipeline.Destination.output_payload_format is not set, then the Pipeline will treat the data field of the message as opaque binary data and attach it to the request body as bytes. In this case the Content-type header will be set to the value of the datacontenttype attribute set on the incoming CloudEvent message if present and the `application/octet-stream` MIME type otherwise. The Pipeline expects that the content of the message will adhere to the standard CloudEvent format. If it doesn’t then the outgoing message request may fail with a persistent error.
  *   `uri` (*type:* `String.t`, *default:* `nil`) - Required. The URI of the HTTP enpdoint. The value must be a RFC2396 URI string. Examples: `http://10.10.10.8:80/route`, `http://svc.us-central1.p.local:8080/`. Only HTTP and HTTPS protocols are supported. The host can be either a static IP addressable from the VPC specified by the network config, or an internal DNS hostname of the service resolvable via Cloud DNS.
  """

  use GoogleApi.Gax.ModelBase

  @type t :: %__MODULE__{
          :messageBindingTemplate => String.t() | nil,
          :uri => String.t() | nil
        }

  field(:messageBindingTemplate)
  field(:uri)
end

defimpl Poison.Decoder,
  for: GoogleApi.Eventarc.V1.Model.GoogleCloudEventarcV1PipelineDestinationHttpEndpoint do
  def decode(value, options) do
    GoogleApi.Eventarc.V1.Model.GoogleCloudEventarcV1PipelineDestinationHttpEndpoint.decode(
      value,
      options
    )
  end
end

defimpl Poison.Encoder,
  for: GoogleApi.Eventarc.V1.Model.GoogleCloudEventarcV1PipelineDestinationHttpEndpoint do
  def encode(value, options) do
    GoogleApi.Gax.ModelBase.encode(value, options)
  end
end
